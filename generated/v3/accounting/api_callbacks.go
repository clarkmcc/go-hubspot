/*
Accounting Extension

These APIs allow you to interact with HubSpot's Accounting Extension. It allows you to: * Specify the URLs that HubSpot will use when making webhook requests to your external accounting system. * Respond to webhook calls made to your external accounting system by HubSpot

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package accounting

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"

	"github.com/clarkmcc/go-hubspot"
	"net/url"
	"strings"
)

// CallbacksApiService CallbacksApi service
type CallbacksApiService service

type ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest struct {
	ctx                        context.Context
	ApiService                 *CallbacksApiService
	requestId                  string
	resultIdAccountingResponse *ResultIdAccountingResponse
}

// The ID of the created customer.
func (r ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest) ResultIdAccountingResponse(resultIdAccountingResponse ResultIdAccountingResponse) ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest {
	r.resultIdAccountingResponse = &resultIdAccountingResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomer Endpoint for customer creation response

Call this endpoint with the response to a customer creation request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomer(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerExecute(r ApiPostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackCustomerCreateRequestIdCreateCustomer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/customer-create/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resultIdAccountingResponse == nil {
		return nil, reportError("resultIdAccountingResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resultIdAccountingResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest struct {
	ctx                            context.Context
	ApiService                     *CallbacksApiService
	requestId                      string
	customerSearchResponseExternal *CustomerSearchResponseExternal
}

// The result of the customer search request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest) CustomerSearchResponseExternal(customerSearchResponseExternal CustomerSearchResponseExternal) ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest {
	r.customerSearchResponseExternal = &customerSearchResponseExternal
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearch Endpoint for customer search response

Call this endpoint with the response to a customer search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearch(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchExecute(r ApiPostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackCustomerSearchRequestIdDoCustomerSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/customer-search/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.customerSearchResponseExternal == nil {
		return nil, reportError("customerSearchResponseExternal is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.customerSearchResponseExternal
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest struct {
	ctx                  context.Context
	ApiService           *CallbacksApiService
	requestId            string
	exchangeRateResponse *ExchangeRateResponse
}

// The result of the exchange rate request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest) ExchangeRateResponse(exchangeRateResponse ExchangeRateResponse) ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest {
	r.exchangeRateResponse = &exchangeRateResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRate Endpoint for exchange rate response

Call this endpoint with the response to an exchange rate request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRate(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateExecute(r ApiPostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackExchangeRateRequestIdCreateExchangeRate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/exchange-rate/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangeRateResponse == nil {
		return nil, reportError("exchangeRateResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exchangeRateResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest struct {
	ctx                        context.Context
	ApiService                 *CallbacksApiService
	requestId                  string
	resultIdAccountingResponse *ResultIdAccountingResponse
}

// The ID of the created invoice.
func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest) ResultIdAccountingResponse(resultIdAccountingResponse ResultIdAccountingResponse) ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest {
	r.resultIdAccountingResponse = &resultIdAccountingResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoice Endpoint for invoice creation response

Call this endpoint with the response to a invoice creation request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoice(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceExecute(r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoiceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackInvoiceCreateRequestIdCreateInvoice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/invoice-create/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resultIdAccountingResponse == nil {
		return nil, reportError("resultIdAccountingResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resultIdAccountingResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest struct {
	ctx                context.Context
	ApiService         *CallbacksApiService
	requestId          string
	invoicePdfResponse *InvoicePdfResponse
}

// The bytes of the invoice PDF.
func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest) InvoicePdfResponse(invoicePdfResponse InvoicePdfResponse) ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest {
	r.invoicePdfResponse = &invoicePdfResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdf Endpoint for PDF content of invoice

Call this endpoint with the PDF content of a requested invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdf(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfExecute(r ApiPostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdfRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackInvoicePdfRequestIdInvoicePdf")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/invoice-pdf/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoicePdfResponse == nil {
		return nil, reportError("invoicePdfResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoicePdfResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest struct {
	ctx                   context.Context
	ApiService            *CallbacksApiService
	requestId             string
	invoiceSearchResponse *InvoiceSearchResponse
}

// The result of the invoice search request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest) InvoiceSearchResponse(invoiceSearchResponse InvoiceSearchResponse) ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest {
	r.invoiceSearchResponse = &invoiceSearchResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearch Endpoint for invoice search response

Call this endpoint with the response to a invoice search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearch(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchExecute(r ApiPostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackInvoiceSearchRequestIdDoInvoiceSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/invoice-search/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoiceSearchResponse == nil {
		return nil, reportError("invoiceSearchResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceSearchResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest struct {
	ctx                      context.Context
	ApiService               *CallbacksApiService
	requestId                string
	invoicesResponseExternal *InvoicesResponseExternal
}

// The result of the invoice request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest) InvoicesResponseExternal(invoicesResponseExternal InvoicesResponseExternal) ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest {
	r.invoicesResponseExternal = &invoicesResponseExternal
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetById Endpoint for invoice get-by-id response

Call this endpoint with the response to a invoice get-by-id request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetById(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdExecute(r ApiPostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackInvoicesRequestIdGetById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/invoices/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoicesResponseExternal == nil {
		return nil, reportError("invoicesResponseExternal is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoicesResponseExternal
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest struct {
	ctx                   context.Context
	ApiService            *CallbacksApiService
	requestId             string
	productSearchResponse *ProductSearchResponse
}

// The result of the product search request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest) ProductSearchResponse(productSearchResponse ProductSearchResponse) ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest {
	r.productSearchResponse = &productSearchResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearch Endpoint for product search response

Call this endpoint with the response to a product search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearch(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchExecute(r ApiPostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackProductSearchRequestIdDoProductSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/product-search/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productSearchResponse == nil {
		return nil, reportError("productSearchResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productSearchResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest struct {
	ctx               context.Context
	ApiService        *CallbacksApiService
	requestId         string
	taxSearchResponse *TaxSearchResponse
}

// The result of the taxes search request.
func (r ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest) TaxSearchResponse(taxSearchResponse TaxSearchResponse) ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest {
	r.taxSearchResponse = &taxSearchResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearch Endpoint for taxes search response

Call this endpoint with the response to a taxes search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearch(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchExecute(r ApiPostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackTaxSearchRequestIdDoTaxSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/tax-search/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.taxSearchResponse == nil {
		return nil, reportError("taxSearchResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.taxSearchResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest struct {
	ctx           context.Context
	ApiService    *CallbacksApiService
	requestId     string
	termsResponse *TermsResponse
}

// The result of the terms search
func (r ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest) TermsResponse(termsResponse TermsResponse) ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest {
	r.termsResponse = &termsResponse
	return r
}

func (r ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermExecute(r)
}

/*
PostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTerm Endpoint for terms search response

Call this endpoint with the response to a terms search request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param requestId The ID of the request that this response is for
 @return ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest
*/
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTerm(ctx context.Context, requestId string) ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest {
	return ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
func (a *CallbacksApiService) PostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermExecute(r ApiPostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTermRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallbacksApiService.PostCrmV3ExtensionsAccountingCallbackTermsRequestIdCreateTerm")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/extensions/accounting/callback/terms/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.termsResponse == nil {
		return nil, reportError("termsResponse is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.termsResponse
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
