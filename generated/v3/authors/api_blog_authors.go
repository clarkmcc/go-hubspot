/*
Blog Post endpoints

Use these endpoints for interacting with Blog Posts, Blog Authors, and Blog Tags

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package authors

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"

	"github.com/clarkmcc/go-hubspot"
	"net/url"
	"reflect"
	"strings"
	"time"
)

// BlogAuthorsApiService BlogAuthorsApi service
type BlogAuthorsApiService service

type ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest struct {
	ctx        context.Context
	ApiService *BlogAuthorsApiService
	objectId   string
	archived   *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest) Archived(archived bool) ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCmsV3BlogsAuthorsObjectIdArchiveExecute(r)
}

/*
DeleteCmsV3BlogsAuthorsObjectIdArchive Delete a Blog Author

Delete the Blog Author object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Author id.
 @return ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest
*/
func (a *BlogAuthorsApiService) DeleteCmsV3BlogsAuthorsObjectIdArchive(ctx context.Context, objectId string) ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest {
	return ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
func (a *BlogAuthorsApiService) DeleteCmsV3BlogsAuthorsObjectIdArchiveExecute(r ApiDeleteCmsV3BlogsAuthorsObjectIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.DeleteCmsV3BlogsAuthorsObjectIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsAuthorsGetPageRequest struct {
	ctx           context.Context
	ApiService    *BlogAuthorsApiService
	createdAt     *time.Time
	createdAfter  *time.Time
	createdBefore *time.Time
	updatedAt     *time.Time
	updatedAfter  *time.Time
	updatedBefore *time.Time
	sort          *[]string
	after         *string
	limit         *int32
	archived      *bool
}

// Only return Blog Authors created at exactly the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Blog Authors created after the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Blog Authors created before the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Blog Authors last updated at exactly the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Blog Authors last updated after the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Blog Authors last updated before the specified time.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) Sort(sort []string) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) After(after string) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) Limit(limit int32) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return deleted Blog Authors. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) Archived(archived bool) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsAuthorsGetPageRequest) Execute() (*CollectionResponseWithTotalBlogAuthorForwardPaging, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogsAuthorsGetPageExecute(r)
}

/*
GetCmsV3BlogsAuthorsGetPage Get all Blog Authors

Get the list of blog authors. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3BlogsAuthorsGetPageRequest
*/
func (a *BlogAuthorsApiService) GetCmsV3BlogsAuthorsGetPage(ctx context.Context) ApiGetCmsV3BlogsAuthorsGetPageRequest {
	return ApiGetCmsV3BlogsAuthorsGetPageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalBlogAuthorForwardPaging
func (a *BlogAuthorsApiService) GetCmsV3BlogsAuthorsGetPageExecute(r ApiGetCmsV3BlogsAuthorsGetPageRequest) (*CollectionResponseWithTotalBlogAuthorForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CollectionResponseWithTotalBlogAuthorForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.GetCmsV3BlogsAuthorsGetPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		localVarQueryParams.Add("createdAt", parameterToString(*r.createdAt, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.updatedAt != nil {
		localVarQueryParams.Add("updatedAt", parameterToString(*r.updatedAt, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.updatedBefore != nil {
		localVarQueryParams.Add("updatedBefore", parameterToString(*r.updatedBefore, ""))
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sort", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sort", parameterToString(t, "multi"))
		}
	}
	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest struct {
	ctx        context.Context
	ApiService *BlogAuthorsApiService
	objectId   string
	archived   *bool
}

// Specifies whether to return deleted Blog Authors. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest) Archived(archived bool) ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest) Execute() (*BlogAuthor, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogsAuthorsObjectIdGetByIdExecute(r)
}

/*
GetCmsV3BlogsAuthorsObjectIdGetById Retrieve a Blog Author

Retrieve the Blog Author object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Author id.
 @return ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest
*/
func (a *BlogAuthorsApiService) GetCmsV3BlogsAuthorsObjectIdGetById(ctx context.Context, objectId string) ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest {
	return ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogAuthor
func (a *BlogAuthorsApiService) GetCmsV3BlogsAuthorsObjectIdGetByIdExecute(r ApiGetCmsV3BlogsAuthorsObjectIdGetByIdRequest) (*BlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.GetCmsV3BlogsAuthorsObjectIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest struct {
	ctx        context.Context
	ApiService *BlogAuthorsApiService
	objectId   string
	blogAuthor *BlogAuthor
	archived   *bool
}

// The JSON representation of the updated Blog Author.
func (r ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest) BlogAuthor(blogAuthor BlogAuthor) ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest {
	r.blogAuthor = &blogAuthor
	return r
}

// Specifies whether to update deleted Blog Authors. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest) Archived(archived bool) ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest) Execute() (*BlogAuthor, *http.Response, error) {
	return r.ApiService.PatchCmsV3BlogsAuthorsObjectIdUpdateExecute(r)
}

/*
PatchCmsV3BlogsAuthorsObjectIdUpdate Update a Blog Author

Sparse updates a single Blog Author object identified by the id in the path.
All the column values need not be specified. Only the that need to be modified can be specified.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Blog Author id.
 @return ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest
*/
func (a *BlogAuthorsApiService) PatchCmsV3BlogsAuthorsObjectIdUpdate(ctx context.Context, objectId string) ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest {
	return ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		objectId:   objectId,
	}
}

// Execute executes the request
//  @return BlogAuthor
func (a *BlogAuthorsApiService) PatchCmsV3BlogsAuthorsObjectIdUpdateExecute(r ApiPatchCmsV3BlogsAuthorsObjectIdUpdateRequest) (*BlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PatchCmsV3BlogsAuthorsObjectIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterToString(r.objectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blogAuthor == nil {
		return localVarReturnValue, nil, reportError("blogAuthor is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogAuthor
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest struct {
	ctx              context.Context
	ApiService       *BlogAuthorsApiService
	batchInputString *BatchInputString
}

// The JSON array of Blog Author ids.
func (r ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsBatchArchiveArchiveBatchExecute(r)
}

/*
PostCmsV3BlogsAuthorsBatchArchiveArchiveBatch Delete a batch of Blog Authors

Delete the Blog Author objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchArchiveArchiveBatch(ctx context.Context) ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest {
	return ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchArchiveArchiveBatchExecute(r ApiPostCmsV3BlogsAuthorsBatchArchiveArchiveBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsBatchArchiveArchiveBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest struct {
	ctx                  context.Context
	ApiService           *BlogAuthorsApiService
	batchInputBlogAuthor *BatchInputBlogAuthor
}

// The JSON array of new Blog Authors to create.
func (r ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest) BatchInputBlogAuthor(batchInputBlogAuthor BatchInputBlogAuthor) ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest {
	r.batchInputBlogAuthor = &batchInputBlogAuthor
	return r
}

func (r ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest) Execute() (*BatchResponseBlogAuthor, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsBatchCreateCreateBatchExecute(r)
}

/*
PostCmsV3BlogsAuthorsBatchCreateCreateBatch Create a batch of Blog Authors

Create the Blog Author objects detailed in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchCreateCreateBatch(ctx context.Context) ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest {
	return ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchResponseBlogAuthor
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchCreateCreateBatchExecute(r ApiPostCmsV3BlogsAuthorsBatchCreateCreateBatchRequest) (*BatchResponseBlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseBlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsBatchCreateCreateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputBlogAuthor == nil {
		return localVarReturnValue, nil, reportError("batchInputBlogAuthor is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputBlogAuthor
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest struct {
	ctx              context.Context
	ApiService       *BlogAuthorsApiService
	batchInputString *BatchInputString
	archived         *bool
}

// The JSON array of Blog Author ids.
func (r ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return deleted Blog Authors. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest) Execute() (*BatchResponseBlogAuthor, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsBatchReadReadBatchExecute(r)
}

/*
PostCmsV3BlogsAuthorsBatchReadReadBatch Retrieve a batch of Blog Authors

Retrieve the Blog Author objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchReadReadBatch(ctx context.Context) ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest {
	return ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchResponseBlogAuthor
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchReadReadBatchExecute(r ApiPostCmsV3BlogsAuthorsBatchReadReadBatchRequest) (*BatchResponseBlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseBlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsBatchReadReadBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest struct {
	ctx                context.Context
	ApiService         *BlogAuthorsApiService
	batchInputJsonNode *BatchInputJsonNode
	archived           *bool
}

// A JSON array of the JSON representations of the updated Blog Authors.
func (r ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Specifies whether to update deleted Blog Authors. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest) Archived(archived bool) ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest) Execute() (*BatchResponseBlogAuthor, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsBatchUpdateUpdateBatchExecute(r)
}

/*
PostCmsV3BlogsAuthorsBatchUpdateUpdateBatch Update a batch of Blog Authors

Update the Blog Author objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchUpdateUpdateBatch(ctx context.Context) ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest {
	return ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BatchResponseBlogAuthor
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsBatchUpdateUpdateBatchExecute(r ApiPostCmsV3BlogsAuthorsBatchUpdateUpdateBatchRequest) (*BatchResponseBlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BatchResponseBlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsBatchUpdateUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsCreateRequest struct {
	ctx        context.Context
	ApiService *BlogAuthorsApiService
	blogAuthor *BlogAuthor
}

// The JSON representation of a new Blog Author.
func (r ApiPostCmsV3BlogsAuthorsCreateRequest) BlogAuthor(blogAuthor BlogAuthor) ApiPostCmsV3BlogsAuthorsCreateRequest {
	r.blogAuthor = &blogAuthor
	return r
}

func (r ApiPostCmsV3BlogsAuthorsCreateRequest) Execute() (*BlogAuthor, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsCreateExecute(r)
}

/*
PostCmsV3BlogsAuthorsCreate Create a new Blog Author

Create a new Blog Author.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsCreateRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsCreate(ctx context.Context) ApiPostCmsV3BlogsAuthorsCreateRequest {
	return ApiPostCmsV3BlogsAuthorsCreateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BlogAuthor
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsCreateExecute(r ApiPostCmsV3BlogsAuthorsCreateRequest) (*BlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blogAuthor == nil {
		return localVarReturnValue, nil, reportError("blogAuthor is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogAuthor
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest struct {
	ctx                             context.Context
	ApiService                      *BlogAuthorsApiService
	attachToLangPrimaryRequestVNext *AttachToLangPrimaryRequestVNext
}

// The JSON representation of the AttachToLangPrimaryRequest object.
func (r ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest) AttachToLangPrimaryRequestVNext(attachToLangPrimaryRequestVNext AttachToLangPrimaryRequestVNext) ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	r.attachToLangPrimaryRequestVNext = &attachToLangPrimaryRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest) Execute() (*Error, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r)
}

/*
PostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroup Attach a Blog Author to a multi-language group

Attach a Blog Author to a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroup(ctx context.Context) ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	return ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Error
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r ApiPostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroupRequest) (*Error, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Error
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsMultiLanguageAttachToLangGroupAttachToLangGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/multi-language/attach-to-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachToLangPrimaryRequestVNext == nil {
		return localVarReturnValue, nil, reportError("attachToLangPrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachToLangPrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest struct {
	ctx                         context.Context
	ApiService                  *BlogAuthorsApiService
	blogAuthorCloneRequestVNext *BlogAuthorCloneRequestVNext
}

// The JSON representation of the ContentLanguageCloneRequest object.
func (r ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest) BlogAuthorCloneRequestVNext(blogAuthorCloneRequestVNext BlogAuthorCloneRequestVNext) ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	r.blogAuthorCloneRequestVNext = &blogAuthorCloneRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest) Execute() (*BlogAuthor, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r)
}

/*
PostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariation Create a new language variation

Create a new language variation from an existing Blog Author.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariation(ctx context.Context) ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	return ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BlogAuthor
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r ApiPostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariationRequest) (*BlogAuthor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BlogAuthor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsMultiLanguageCreateLanguageVariationCreateLangVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/multi-language/create-language-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blogAuthorCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("blogAuthorCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogAuthorCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest struct {
	ctx                             context.Context
	ApiService                      *BlogAuthorsApiService
	detachFromLangGroupRequestVNext *DetachFromLangGroupRequestVNext
}

// The JSON representation of the DetachFromLangGroupRequest object.
func (r ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) DetachFromLangGroupRequestVNext(detachFromLangGroupRequestVNext DetachFromLangGroupRequestVNext) ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	r.detachFromLangGroupRequestVNext = &detachFromLangGroupRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) Execute() (*Error, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r)
}

/*
PostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroup Detach a Blog Author from a multi-language group

Detach a Blog Author from a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroup(ctx context.Context) ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	return ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Error
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r ApiPostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) (*Error, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Error
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsMultiLanguageDetachFromLangGroupDetachFromLangGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/multi-language/detach-from-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.detachFromLangGroupRequestVNext == nil {
		return localVarReturnValue, nil, reportError("detachFromLangGroupRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.detachFromLangGroupRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest struct {
	ctx                         context.Context
	ApiService                  *BlogAuthorsApiService
	updateLanguagesRequestVNext *UpdateLanguagesRequestVNext
}

// The JSON representation of the UpdateLanguagesRequest object.
func (r ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest) UpdateLanguagesRequestVNext(updateLanguagesRequestVNext UpdateLanguagesRequestVNext) ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest {
	r.updateLanguagesRequestVNext = &updateLanguagesRequestVNext
	return r
}

func (r ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest) Execute() (*Error, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsExecute(r)
}

/*
PostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangs Update languages of multi-language group

Explicitly set new languages for each Blog Author in a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest
*/
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangs(ctx context.Context) ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest {
	return ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Error
func (a *BlogAuthorsApiService) PostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsExecute(r ApiPostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangsRequest) (*Error, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Error
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PostCmsV3BlogsAuthorsMultiLanguageUpdateLanguagesUpdateLangs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/multi-language/update-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLanguagesRequestVNext == nil {
		return localVarReturnValue, nil, reportError("updateLanguagesRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLanguagesRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest struct {
	ctx                               context.Context
	ApiService                        *BlogAuthorsApiService
	setNewLanguagePrimaryRequestVNext *SetNewLanguagePrimaryRequestVNext
}

// The JSON representation of the SetNewLanguagePrimaryRequest object.
func (r ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) SetNewLanguagePrimaryRequestVNext(setNewLanguagePrimaryRequestVNext SetNewLanguagePrimaryRequestVNext) ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	r.setNewLanguagePrimaryRequestVNext = &setNewLanguagePrimaryRequestVNext
	return r
}

func (r ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r)
}

/*
PutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimary Set a new primary language

Set a Blog Author as the primary language of a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest
*/
func (a *BlogAuthorsApiService) PutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimary(ctx context.Context) ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	return ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *BlogAuthorsApiService) PutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r ApiPutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogAuthorsApiService.PutCmsV3BlogsAuthorsMultiLanguageSetNewLangPrimarySetLangPrimary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blogs/authors/multi-language/set-new-lang-primary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setNewLanguagePrimaryRequestVNext == nil {
		return nil, reportError("setNewLanguagePrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setNewLanguagePrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
