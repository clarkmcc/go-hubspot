/*
CMS Site Search

Use these endpoints for searching content on your HubSpot hosted CMS website(s).

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package site_search

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// PublicApiService PublicApi service
type PublicApiService service

type ApiGetByIDRequest struct {
	ctx        context.Context
	ApiService *PublicApiService
	contentId  string
	type_      *string
}

// The type of document. Can be one of &#x60;SITE_PAGE&#x60;, &#x60;BLOG_POST&#x60;, or &#x60;KNOWLEDGE_ARTICLE&#x60;.
func (r ApiGetByIDRequest) Type_(type_ string) ApiGetByIDRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetByIDRequest) Execute() (*IndexedData, *http.Response, error) {
	return r.ApiService.GetByIDExecute(r)
}

/*
GetByID Get indexed properties.

For a given account and document ID (page ID, blog post ID, HubDB row ID, etc.), return all indexed data for that document. This is useful when debugging why a particular document is not returned from a custom search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentId ID of the target document when searching for indexed properties.
 @return ApiGetByIDRequest
*/
func (a *PublicApiService) GetByID(ctx context.Context, contentId string) ApiGetByIDRequest {
	return ApiGetByIDRequest{
		ApiService: a,
		ctx:        ctx,
		contentId:  contentId,
	}
}

// Execute executes the request
//  @return IndexedData
func (a *PublicApiService) GetByIDExecute(r ApiGetByIDRequest) (*IndexedData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IndexedData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.GetByID")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/site-search/indexed-data/{contentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", url.PathEscape(parameterToString(r.contentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRequest struct {
	ctx             context.Context
	ApiService      *PublicApiService
	q               *string
	limit           *int32
	offset          *int32
	language        *string
	matchPrefix     *bool
	autocomplete    *bool
	popularityBoost *float32
	boostLimit      *float32
	boostRecent     *string
	tableId         *int64
	hubdbQuery      *string
	domain          *[]string
	type_           *[]string
	pathPrefix      *[]string
	property        *[]string
	length          *string
	groupId         *[]int64
}

// The term to search for.
func (r ApiSearchRequest) Q(q string) ApiSearchRequest {
	r.q = &q
	return r
}

// Specifies the number of results to be returned in a single response. Defaults to &#x60;10&#x60;. Maximum value is &#x60;100&#x60;.
func (r ApiSearchRequest) Limit(limit int32) ApiSearchRequest {
	r.limit = &limit
	return r
}

// Used to page through the results. If there are more results than specified by the &#x60;limit&#x60; parameter, you will need to use the value of offset returned in the previous request to get the next set of results.
func (r ApiSearchRequest) Offset(offset int32) ApiSearchRequest {
	r.offset = &offset
	return r
}

// Specifies the language of content to be searched. This value must be a valid [ISO 639-1 language code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;es&#x60; for Spanish)
func (r ApiSearchRequest) Language(language string) ApiSearchRequest {
	r.language = &language
	return r
}

// Inverts the behavior of the pathPrefix filter when set to &#x60;false&#x60;. Defaults to &#x60;true&#x60;.
func (r ApiSearchRequest) MatchPrefix(matchPrefix bool) ApiSearchRequest {
	r.matchPrefix = &matchPrefix
	return r
}

// Specifies whether or not you are showing autocomplete results. Defaults to false.
func (r ApiSearchRequest) Autocomplete(autocomplete bool) ApiSearchRequest {
	r.autocomplete = &autocomplete
	return r
}

// Specifies how strongly a result is boosted based on its view count. Defaults to 1.0.
func (r ApiSearchRequest) PopularityBoost(popularityBoost float32) ApiSearchRequest {
	r.popularityBoost = &popularityBoost
	return r
}

// Specifies the maximum amount a result will be boosted based on its view count. Defaults to 5.0. Read more about elasticsearch boosting [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-boost.html).
func (r ApiSearchRequest) BoostLimit(boostLimit float32) ApiSearchRequest {
	r.boostLimit = &boostLimit
	return r
}

// Specifies a relative time window where scores of documents published outside this time window decay. This can only be used for blog posts. For example, boostRecent&#x3D;10d will boost documents published within the last 10 days. Supported timeunits are ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
func (r ApiSearchRequest) BoostRecent(boostRecent string) ApiSearchRequest {
	r.boostRecent = &boostRecent
	return r
}

// Specifies a specific HubDB table to search. Only returns results from the specified table. Can be used in tandem with the &#x60;hubdbQuery&#x60; parameter to further filter results.
func (r ApiSearchRequest) TableId(tableId int64) ApiSearchRequest {
	r.tableId = &tableId
	return r
}

// Specify a HubDB query to further filter the search results.
func (r ApiSearchRequest) HubdbQuery(hubdbQuery string) ApiSearchRequest {
	r.hubdbQuery = &hubdbQuery
	return r
}

// A domain to match search results for. Multiple domains can be provided with &amp;.
func (r ApiSearchRequest) Domain(domain []string) ApiSearchRequest {
	r.domain = &domain
	return r
}

// Specifies the type of content to search. Can be one or more of SITE_PAGE, LANDING_PAGE, BLOG_POST, LISTING_PAGE, and KNOWLEDGE_ARTICLE. Defaults to all content types except LANDING_PAGE and KNOWLEDGE_ARTICLE
func (r ApiSearchRequest) Type_(type_ []string) ApiSearchRequest {
	r.type_ = &type_
	return r
}

// Specifies a path prefix to filter search results. Will only return results with URL paths that start with the specified parameter. Can be used multiple times.
func (r ApiSearchRequest) PathPrefix(pathPrefix []string) ApiSearchRequest {
	r.pathPrefix = &pathPrefix
	return r
}

// Specifies which properties to include in the search. Options include &#x60;title&#x60;, &#x60;description&#x60;, and &#x60;html&#x60;. All properties will be searched by default.
func (r ApiSearchRequest) Property(property []string) ApiSearchRequest {
	r.property = &property
	return r
}

// Specifies the length of the search results. Can be set to &#x60;LONG&#x60; or &#x60;SHORT&#x60;. &#x60;SHORT&#x60; will return the first 128 characters of the content&#39;s meta description. &#x60;LONG&#x60; will build a more detailed content snippet based on the html/content of the page.
func (r ApiSearchRequest) Length(length string) ApiSearchRequest {
	r.length = &length
	return r
}

// Specifies which blog(s) to be searched by blog ID. Can be used multiple times to search more than one blog.
func (r ApiSearchRequest) GroupId(groupId []int64) ApiSearchRequest {
	r.groupId = &groupId
	return r
}

func (r ApiSearchRequest) Execute() (*PublicSearchResults, *http.Response, error) {
	return r.ApiService.SearchExecute(r)
}

/*
Search Search your site.

Returns any website content matching the given search criteria for a given HubSpot account. Searches can be filtered by content type, domain, or URL path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRequest
*/
func (a *PublicApiService) Search(ctx context.Context) ApiSearchRequest {
	return ApiSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PublicSearchResults
func (a *PublicApiService) SearchExecute(r ApiSearchRequest) (*PublicSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.Search")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/site-search/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	if r.matchPrefix != nil {
		localVarQueryParams.Add("matchPrefix", parameterToString(*r.matchPrefix, ""))
	}
	if r.autocomplete != nil {
		localVarQueryParams.Add("autocomplete", parameterToString(*r.autocomplete, ""))
	}
	if r.popularityBoost != nil {
		localVarQueryParams.Add("popularityBoost", parameterToString(*r.popularityBoost, ""))
	}
	if r.boostLimit != nil {
		localVarQueryParams.Add("boostLimit", parameterToString(*r.boostLimit, ""))
	}
	if r.boostRecent != nil {
		localVarQueryParams.Add("boostRecent", parameterToString(*r.boostRecent, ""))
	}
	if r.tableId != nil {
		localVarQueryParams.Add("tableId", parameterToString(*r.tableId, ""))
	}
	if r.hubdbQuery != nil {
		localVarQueryParams.Add("hubdbQuery", parameterToString(*r.hubdbQuery, ""))
	}
	if r.domain != nil {
		t := *r.domain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("domain", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("domain", parameterToString(t, "multi"))
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.pathPrefix != nil {
		t := *r.pathPrefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("pathPrefix", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("pathPrefix", parameterToString(t, "multi"))
		}
	}
	if r.property != nil {
		t := *r.property
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("property", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("property", parameterToString(t, "multi"))
		}
	}
	if r.length != nil {
		localVarQueryParams.Add("length", parameterToString(*r.length, ""))
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("groupId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("groupId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["private_apps_legacy"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["private-app-legacy"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
