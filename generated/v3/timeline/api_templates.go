/*
CRM Timeline

This feature allows an app to create and configure custom events that can show up in the timelines of certain CRM objects like contacts, companies, tickets, or deals. You'll find multiple use cases for this API in the sections below.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package timeline

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"

	"github.com/clarkmcc/go-hubspot"
	"net/url"
	"strings"
)

// TemplatesApiService TemplatesApi service
type TemplatesApiService service

type ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest struct {
	ctx             context.Context
	ApiService      *TemplatesApiService
	eventTemplateId string
	appId           int32
}

func (r ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveExecute(r)
}

/*
DeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchive Deletes an event template for the app

This will delete the event template. All associated events will be removed from search results and the timeline UI.

This action can't be undone, so it's highly recommended that you stop using any associated events before deleting a template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventTemplateId The event template ID.
 @param appId The ID of the target app.
 @return ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest
*/
func (a *TemplatesApiService) DeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchive(ctx context.Context, eventTemplateId string, appId int32) ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest {
	return ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest{
		ApiService:      a,
		ctx:             ctx,
		eventTemplateId: eventTemplateId,
		appId:           appId,
	}
}

// Execute executes the request
func (a *TemplatesApiService) DeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveExecute(r ApiDeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesApiService.DeleteCrmV3TimelineAppIdEventTemplatesEventTemplateIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/timeline/{appId}/event-templates/{eventTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventTemplateId"+"}", url.PathEscape(parameterToString(r.eventTemplateId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest struct {
	ctx             context.Context
	ApiService      *TemplatesApiService
	eventTemplateId string
	appId           int32
}

func (r ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest) Execute() (*TimelineEventTemplate, *http.Response, error) {
	return r.ApiService.GetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdExecute(r)
}

/*
GetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetById Gets a specific event template for your app

View the current state of a specific template and its tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventTemplateId The event template ID.
 @param appId The ID of the target app.
 @return ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest
*/
func (a *TemplatesApiService) GetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetById(ctx context.Context, eventTemplateId string, appId int32) ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest {
	return ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest{
		ApiService:      a,
		ctx:             ctx,
		eventTemplateId: eventTemplateId,
		appId:           appId,
	}
}

// Execute executes the request
//  @return TimelineEventTemplate
func (a *TemplatesApiService) GetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdExecute(r ApiGetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetByIdRequest) (*TimelineEventTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TimelineEventTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesApiService.GetCrmV3TimelineAppIdEventTemplatesEventTemplateIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/timeline/{appId}/event-templates/{eventTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventTemplateId"+"}", url.PathEscape(parameterToString(r.eventTemplateId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest struct {
	ctx        context.Context
	ApiService *TemplatesApiService
	appId      int32
}

func (r ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest) Execute() (*CollectionResponseTimelineEventTemplateNoPaging, *http.Response, error) {
	return r.ApiService.GetCrmV3TimelineAppIdEventTemplatesGetAllExecute(r)
}

/*
GetCrmV3TimelineAppIdEventTemplatesGetAll List all event templates for your app

Use this to list all event templates owned by your app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId The ID of the target app.
 @return ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest
*/
func (a *TemplatesApiService) GetCrmV3TimelineAppIdEventTemplatesGetAll(ctx context.Context, appId int32) ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest {
	return ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest{
		ApiService: a,
		ctx:        ctx,
		appId:      appId,
	}
}

// Execute executes the request
//  @return CollectionResponseTimelineEventTemplateNoPaging
func (a *TemplatesApiService) GetCrmV3TimelineAppIdEventTemplatesGetAllExecute(r ApiGetCrmV3TimelineAppIdEventTemplatesGetAllRequest) (*CollectionResponseTimelineEventTemplateNoPaging, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CollectionResponseTimelineEventTemplateNoPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesApiService.GetCrmV3TimelineAppIdEventTemplatesGetAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/timeline/{appId}/event-templates"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest struct {
	ctx                                context.Context
	ApiService                         *TemplatesApiService
	appId                              int32
	timelineEventTemplateCreateRequest *TimelineEventTemplateCreateRequest
}

// The new event template definition.
func (r ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest) TimelineEventTemplateCreateRequest(timelineEventTemplateCreateRequest TimelineEventTemplateCreateRequest) ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest {
	r.timelineEventTemplateCreateRequest = &timelineEventTemplateCreateRequest
	return r
}

func (r ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest) Execute() (*TimelineEventTemplate, *http.Response, error) {
	return r.ApiService.PostCrmV3TimelineAppIdEventTemplatesCreateExecute(r)
}

/*
PostCrmV3TimelineAppIdEventTemplatesCreate Create an event template for your app

Event templates define the general structure for a custom timeline event. This includes formatted copy for its heading and details, as well as any custom property definitions. The event could be something like viewing a video, registering for a webinar, or filling out a survey. A single app can define multiple event templates.

Event templates will be created for contacts by default, but they can be created for companies, tickets, and deals as well.

Each event template contains its own set of tokens and `Markdown` templates. These tokens can be associated with any CRM object properties via the `objectPropertyName` field to fully build out CRM objects.

You must create an event template before you can create events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appId The ID of the target app.
 @return ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest
*/
func (a *TemplatesApiService) PostCrmV3TimelineAppIdEventTemplatesCreate(ctx context.Context, appId int32) ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest {
	return ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest{
		ApiService: a,
		ctx:        ctx,
		appId:      appId,
	}
}

// Execute executes the request
//  @return TimelineEventTemplate
func (a *TemplatesApiService) PostCrmV3TimelineAppIdEventTemplatesCreateExecute(r ApiPostCrmV3TimelineAppIdEventTemplatesCreateRequest) (*TimelineEventTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TimelineEventTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesApiService.PostCrmV3TimelineAppIdEventTemplatesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/timeline/{appId}/event-templates"
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timelineEventTemplateCreateRequest == nil {
		return localVarReturnValue, nil, reportError("timelineEventTemplateCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timelineEventTemplateCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest struct {
	ctx                                context.Context
	ApiService                         *TemplatesApiService
	eventTemplateId                    string
	appId                              int32
	timelineEventTemplateUpdateRequest *TimelineEventTemplateUpdateRequest
}

// The updated event template definition.
func (r ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest) TimelineEventTemplateUpdateRequest(timelineEventTemplateUpdateRequest TimelineEventTemplateUpdateRequest) ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest {
	r.timelineEventTemplateUpdateRequest = &timelineEventTemplateUpdateRequest
	return r
}

func (r ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest) Execute() (*TimelineEventTemplate, *http.Response, error) {
	return r.ApiService.PutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateExecute(r)
}

/*
PutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdate Update an existing event template

Updates an existing template and its tokens. This is primarily used to update the headerTemplate/detailTemplate, and those changes will take effect for existing events.

You can also update or replace all the tokens in the template here instead of doing individual API calls on the `/tokens` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventTemplateId The event template ID.
 @param appId The ID of the target app.
 @return ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest
*/
func (a *TemplatesApiService) PutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdate(ctx context.Context, eventTemplateId string, appId int32) ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest {
	return ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest{
		ApiService:      a,
		ctx:             ctx,
		eventTemplateId: eventTemplateId,
		appId:           appId,
	}
}

// Execute executes the request
//  @return TimelineEventTemplate
func (a *TemplatesApiService) PutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateExecute(r ApiPutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdateRequest) (*TimelineEventTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TimelineEventTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TemplatesApiService.PutCrmV3TimelineAppIdEventTemplatesEventTemplateIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/timeline/{appId}/event-templates/{eventTemplateId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventTemplateId"+"}", url.PathEscape(parameterToString(r.eventTemplateId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterToString(r.appId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timelineEventTemplateUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("timelineEventTemplateUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timelineEventTemplateUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
