/*
CMS Site Search

Use these endpoints for searching content on your HubSpot hosted CMS website(s).

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package site_search

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PublicApiService PublicApi service
type PublicApiService service

type ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest struct {
	ctx        _context.Context
	ApiService *PublicApiService
	contentId  string
	type_      *string
}

// The type of document. Can be one of &#x60;SITE_PAGE&#x60;, &#x60;BLOG_POST&#x60;, or &#x60;KNOWLEDGE_ARTICLE&#x60;.
func (r ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest) Type_(type_ string) ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest) Execute() (IndexedData, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3SiteSearchIndexedDataContentIdGetByIdExecute(r)
}

/*
GetCmsV3SiteSearchIndexedDataContentIdGetById Get indexed properties.

For a given account and document ID (page ID, blog post ID, HubDB row ID, etc.), return all indexed data for that document. This is useful when debugging why a particular document is not returned from a custom search.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentId ID of the target document when searching for indexed properties.
 @return ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest
*/
func (a *PublicApiService) GetCmsV3SiteSearchIndexedDataContentIdGetById(ctx _context.Context, contentId string) ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest {
	return ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		contentId:  contentId,
	}
}

// Execute executes the request
//  @return IndexedData
func (a *PublicApiService) GetCmsV3SiteSearchIndexedDataContentIdGetByIdExecute(r ApiGetCmsV3SiteSearchIndexedDataContentIdGetByIdRequest) (IndexedData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IndexedData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.GetCmsV3SiteSearchIndexedDataContentIdGetById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/site-search/indexed-data/{contentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", _neturl.PathEscape(parameterToString(r.contentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3SiteSearchSearchSearchRequest struct {
	ctx             _context.Context
	ApiService      *PublicApiService
	q               *string
	limit           *int32
	offset          *int32
	language        *string
	matchPrefix     *bool
	autocomplete    *bool
	popularityBoost *float32
	boostLimit      *float32
	minScore        *float32
	boostRecent     *string
	tableId         *int64
	hubdbQuery      *string
	domain          *[]string
	type_           *[]string
	pathPrefix      *[]string
	property        *[]string
	length          *string
	groupId         *[]int64
}

// The term to search for.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Q(q string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.q = &q
	return r
}

// Specifies the number of results to be returned in a single response. Defaults to &#x60;10&#x60;. Maximum value is &#x60;100&#x60;.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Limit(limit int32) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.limit = &limit
	return r
}

// Used to page through the results. If there are more results than specified by the &#x60;limit&#x60; parameter, you will need to use the value of offset returned in the previous request to get the next set of results.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Offset(offset int32) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.offset = &offset
	return r
}

// Specifies the language of content to be searched. This value must be a valid [ISO 639-1 language code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. &#x60;es&#x60; for Spanish)
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Language(language string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.language = &language
	return r
}

// Inverts the behavior of the pathPrefix filter when set to &#x60;false&#x60;. Defaults to &#x60;true&#x60;.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) MatchPrefix(matchPrefix bool) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.matchPrefix = &matchPrefix
	return r
}

// Specifies whether or not you are showing autocomplete results. Defaults to false.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Autocomplete(autocomplete bool) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.autocomplete = &autocomplete
	return r
}

// Specifies how strongly a result is boosted based on its view count. Defaults to 1.0.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) PopularityBoost(popularityBoost float32) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.popularityBoost = &popularityBoost
	return r
}

// Specifies the maximum amount a result will be boosted based on its view count. Defaults to 5.0. Read more about elasticsearch boosting [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-boost.html).
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) BoostLimit(boostLimit float32) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.boostLimit = &boostLimit
	return r
}

// Specifies the minimum search score threshold for returned results. This value is intentionally set low by default in order to return many results. Increase this for higher precision, but less recall.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) MinScore(minScore float32) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.minScore = &minScore
	return r
}

// Specifies a relative time window where scores of documents published outside this time window decay. This can only be used for blog posts. For example, boostRecent&#x3D;10d will boost documents published within the last 10 days. Supported timeunits are ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) BoostRecent(boostRecent string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.boostRecent = &boostRecent
	return r
}

// Specifies a specific HubDB table to search. Only returns results from the specified table. Can be used in tandem with the &#x60;hubdbQuery&#x60; parameter to further filter results.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) TableId(tableId int64) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.tableId = &tableId
	return r
}

// Specify a HubDB query to further filter the search results.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) HubdbQuery(hubdbQuery string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.hubdbQuery = &hubdbQuery
	return r
}

// A domain to match search results for. Multiple domains can be provided with &amp;.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Domain(domain []string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.domain = &domain
	return r
}

// Specifies the type of content to search. Can be one or more of SITE_PAGE, LANDING_PAGE, BLOG_POST, LISTING_PAGE, and KNOWLEDGE_ARTICLE. Defaults to all content types except LANDING_PAGE and KNOWLEDGE_ARTICLE
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Type_(type_ []string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.type_ = &type_
	return r
}

// Specifies a path prefix to filter search results. Will only return results with URL paths that start with the specified parameter. Can be used multiple times.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) PathPrefix(pathPrefix []string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.pathPrefix = &pathPrefix
	return r
}

// Specifies which properties to include in the search. Options include &#x60;title&#x60;, &#x60;description&#x60;, and &#x60;html&#x60;. All properties will be searched by default.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Property(property []string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.property = &property
	return r
}

// Specifies the length of the search results. Can be set to &#x60;LONG&#x60; or &#x60;SHORT&#x60;. &#x60;SHORT&#x60; will return the first 128 characters of the content&#39;s meta description. &#x60;LONG&#x60; will build a more detailed content snippet based on the html/content of the page.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Length(length string) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.length = &length
	return r
}

// Specifies which blog(s) to be searched by blog ID. Can be used multiple times to search more than one blog.
func (r ApiGetCmsV3SiteSearchSearchSearchRequest) GroupId(groupId []int64) ApiGetCmsV3SiteSearchSearchSearchRequest {
	r.groupId = &groupId
	return r
}

func (r ApiGetCmsV3SiteSearchSearchSearchRequest) Execute() (PublicSearchResults, *_nethttp.Response, error) {
	return r.ApiService.GetCmsV3SiteSearchSearchSearchExecute(r)
}

/*
GetCmsV3SiteSearchSearchSearch Search your site.

Returns any website content matching the given search criteria for a given HubSpot account. Searches can be filtered by content type, domain, or URL path.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3SiteSearchSearchSearchRequest
*/
func (a *PublicApiService) GetCmsV3SiteSearchSearchSearch(ctx _context.Context) ApiGetCmsV3SiteSearchSearchSearchRequest {
	return ApiGetCmsV3SiteSearchSearchSearchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return PublicSearchResults
func (a *PublicApiService) GetCmsV3SiteSearchSearchSearchExecute(r ApiGetCmsV3SiteSearchSearchSearchRequest) (PublicSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PublicSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicApiService.GetCmsV3SiteSearchSearchSearch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/site-search/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	if r.matchPrefix != nil {
		localVarQueryParams.Add("matchPrefix", parameterToString(*r.matchPrefix, ""))
	}
	if r.autocomplete != nil {
		localVarQueryParams.Add("autocomplete", parameterToString(*r.autocomplete, ""))
	}
	if r.popularityBoost != nil {
		localVarQueryParams.Add("popularityBoost", parameterToString(*r.popularityBoost, ""))
	}
	if r.boostLimit != nil {
		localVarQueryParams.Add("boostLimit", parameterToString(*r.boostLimit, ""))
	}
	if r.minScore != nil {
		localVarQueryParams.Add("minScore", parameterToString(*r.minScore, ""))
	}
	if r.boostRecent != nil {
		localVarQueryParams.Add("boostRecent", parameterToString(*r.boostRecent, ""))
	}
	if r.tableId != nil {
		localVarQueryParams.Add("tableId", parameterToString(*r.tableId, ""))
	}
	if r.hubdbQuery != nil {
		localVarQueryParams.Add("hubdbQuery", parameterToString(*r.hubdbQuery, ""))
	}
	if r.domain != nil {
		t := *r.domain
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("domain", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("domain", parameterToString(t, "multi"))
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("type", parameterToString(t, "multi"))
		}
	}
	if r.pathPrefix != nil {
		t := *r.pathPrefix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("pathPrefix", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("pathPrefix", parameterToString(t, "multi"))
		}
	}
	if r.property != nil {
		t := *r.property
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("property", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("property", parameterToString(t, "multi"))
		}
	}
	if r.length != nil {
		localVarQueryParams.Add("length", parameterToString(*r.length, ""))
	}
	if r.groupId != nil {
		t := *r.groupId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("groupId", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("groupId", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["hapikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("hapikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Error
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
